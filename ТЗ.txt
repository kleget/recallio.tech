ТЕХНИЧЕСКОЕ ЗАДАНИЕ (ТЗ)
Тема: Идеальная подготовка корпусов для Recallio (двунаправленное RU<->EN обучение)

ЦЕЛЬ
Собрать корпуса так, чтобы:
1) RU->EN и EN->RU показывали один и тот же набор слов (одинаковая структура, разные языки внутри одной записи).
2) Качество переводов было стабильным, без пропаж, дублей и «грязных» вариантов.
3) Данные легко чистились, переиспользовались и обновлялись без потери логики.

ОСНОВНАЯ МОДЕЛЬ (ЛУЧШИЙ ВАРИАНТ)
Использовать entry-подход: каждая единица обучения — «entry» с набором терминов на разных языках.

РЕКОМЕНДОВАННЫЙ ФОРМАТ SQLITE
1) corpora
- slug TEXT PRIMARY KEY           (уникальный id корпуса, например it_ru_en)
- name TEXT                       (человекочитаемое имя)
- description TEXT                (опционально)
- source_lang TEXT                (например ru)
- target_lang TEXT                (например en)
- version TEXT                    (опционально, версия сборки)
- created_at TEXT                 (опционально)

2) entries
- id INTEGER PRIMARY KEY
- corpus_slug TEXT                (FK -> corpora.slug)
- count INTEGER                   (частота/вес)
- rank INTEGER                    (ранг; чем меньше — тем важнее)
- note TEXT                       (опционально, служебная инфа)

3) terms
- id INTEGER PRIMARY KEY
- entry_id INTEGER                (FK -> entries.id)
- lang TEXT                       (ru / en)
- lemma TEXT                      (исходное отображаемое слово/фраза)
- lemma_key TEXT                  (нормализованный ключ, lower + trim + унификация пробелов)
- is_primary INTEGER DEFAULT 0    (главный термин по языку)
- pos TEXT                        (часть речи, опционально)
- form_tag TEXT                   (например plural, past, gerund, опционально)
- note TEXT                       (опционально)

4) examples (опционально, но очень желательно)
- id INTEGER PRIMARY KEY
- entry_id INTEGER
- lang TEXT
- sentence TEXT
- source TEXT

5) meta (опционально)
- key TEXT PRIMARY KEY
- value TEXT

ВАЖНЫЕ ТРЕБОВАНИЯ К ДАННЫМ
1) ВАЖНО: У каждого entry должен быть минимум 1 термин на RU и 1 термин на EN.
2) ВАЖНО: Ровно один is_primary=1 на каждый язык внутри entry (если есть больше — привести к одному).
3) НЕЛЬЗЯ: Склеивать разные entry из‑за общих переводов (например «bank»).
4) НЕЛЬЗЯ: Хранить в одном термине «data / information» — это должны быть 2 термина.
5) НЕЛЬЗЯ: Пустые или «мусорные» термины.

ПРАВИЛА НОРМАЛИЗАЦИИ
1) lemma_key = lower(trim) + unify whitespace (1 пробел).
2) Удалить «хвосты» типа «(tech)», «(informal)» — если нужно, хранить в note/pos.
3) Удалить лишние пробелы, табы, несколько пробелов подряд.
4) Сохранять оригинальный lemma (с правильным регистром), но ключ сравнения делать по lemma_key.

ФИЛЬТРАЦИЯ МУСОРА
1) Удалять значения короче 2 символов (кроме допустимых аббревиатур — задаётся списком).
2) Удалять термины с процентом «небуквенных» символов выше порога (например > 40%).
3) Удалять подозрительные повторяющиеся символы ("aaaa", "----").
4) Удалять/исправлять «битые» кодировки.

ДЕДУПЛИКАЦИЯ
1) Внутри одного entry:
   - удалить дубли по (lang, lemma_key).
2) Между entry:
   - не объединять автоматически, если совпадает перевод.
   - объединять только при явном совпадении всех ключевых терминов или по ручной маркировке.

ЧАСТОТА И РАНГ
1) count и rank относятся к entry (а не к отдельному термину).
2) count = максимальная частота из всех вариантов внутри entry.
3) rank = минимальный ранг по источнику.

КОНТРОЛЬ КАЧЕСТВА (QA)
Перед импортом в Postgres выполнить проверки:
1) % entry без RU или без EN = 0.
2) % entry с >1 primary на языке = 0.
3) % entry с пустыми term = 0.
4) Дубликаты по (entry_id, lang, lemma_key) = 0.
5) Статистика: среднее число терминов на entry по языкам.
6) ТОП-100 по частоте с ручной проверкой.

ПРОЦЕСС ИМПОРТА
1) Импортировать corpora.
2) Импортировать entries.
3) Импортировать terms.
4) Импортировать examples (если есть).
5) Пересчитать/пересобрать corpus_entries в Postgres.

ПОЛИТИКА ОБНОВЛЕНИЙ
1) Если структура entry‑based, то при импорте можно делать полную пересборку (reset).
2) Все ручные правки в админке должны делаться поверх entries и храниться в `corpus_entry_terms`.
3) При новых версиях корпусов — хранить версию и запускать полный rebuild.

РЕЗУЛЬТАТ
После внедрения:
- Один и тот же набор слов виден в обе стороны.
- Переводы не пропадают после смены направления.
- Можно корректно добавлять вторые значения и переводы в админке.
- Нет грязных склеек и дубликатов.

ГОТОВНОСТЬ
Если формат SQLite будет таким, я сделаю импортёр под эту схему и все проверки.
